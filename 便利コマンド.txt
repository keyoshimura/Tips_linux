●セッション切れする時は...
screenコマンドを使おう。
http://kagasu.hatenablog.com/entry/20160627/1467012578
http://dasunhegoda.com/unix-screen-command/263/

名前をつけてscreenを作成
screen -S hoge

切り替え
screen -r　[processesID]

セッション一覧表示
screen -ls

名前をつけてscreenを作成（デタッチした状態で開始）
screen -dmS hoge

外部から終了する
screen -S hoge -X quit

外部から任意のコマンドを実行する
# 名前が hoge のセッションで ls を実行する
screen -S hoge -X stuff 'ls'`echo -ne '\015'`

screenを削除する。
コマンドでも削除できそうだけど、間違えて削除するのが怖いから、exitで抜けていけば削除できるのでそちらで。

まあ、どうしてもコマンドで消すのなら、下記のコマンドで「デタッチされている」スクリーンなら消せる。
screen -X -S SCREENID quit

・デタッチする
Ctrlと「A」を同時に押しましたのちに、D


●ディレクトリを削除
rm -rf ディレクトリ名

●結果をファイルに書き出す

・標準出力をファイルに書き出す（上書きしてしまうので注意）
>

・標準出力をファイルに書き出す（ファイルがあれば追加で書き出す）
>>

・標準エラー出力をファイルに書き出す（上書きしてしまうので注意）
2>

・標準エラー出力をファイルに書き出す（ファイルがあれば追加で書き出す）
2>>

・標準出力、エラー内容を同じファイルに書き出す（上書きしてしまうので注意）
>&

●ファイルコピー
①元ファイルの属性を保持したまま、ファイルコピーをする。（特に何も指定しないと、オーナーや更新日時が元ファイルと異なる）
「-p」オプションをつける。
$cp -p cat_test.txt cat_test_copied_2.txt


②ディレクトリを丸ごとコピーする
「R」オプションをつける。下記は「sample_1」ディレクトリをtmpディレクトリ直下にコピーしている。

$cp -R sample_1 tmp/ # tmpディレクトリ直下にコピー
上記コマンドを再度実行すると、同じ名前のファイルは上書きされる。
ただし、コピー元にないファイルについては、そのまま。

$cp -R sample_1 tmp/sample_2 # tmpディレクトリ直下に「sample_2」というディレクトリ名でコピー 
もし「tmp/sample_2」ディレクトリがすでに存在する場合は、「tmp/sample_2」ディレクトリ直下に「sample_1」ディレクトリが作成される。

③複数のファイルを、名前を指定してコピーする
$cp cat_test.txt cal.csv tmp # cat_test.txt、cal.csvをtmpディレクトリにコピーする

⓸カレントディレクトリを丸ごとコピー
$cp -pR . tmp # tmpディレクトリにコピー

「-p」オプションをつけて、ファイルの元属性をそのままコピーする。
「-R」オプションをつけることで、ディレクトリのコピーが可能。

●ファイル移動
mvコマンド。

①複数ファイルを移動
$ mv cal.csv cat_test.txt tmp # tmpディレクトリに移動


●シンボリックリンク作成
Windowsで言う所の「ショートカット」をLinuxでは「シンボリックリンク」もしくは「ハードリンク」と呼んでいる。
あまり使うことはないかと思いますが。

$ ln -s [元のファイルのパス] [シンボリックリンクのパス]
これで元ファイルに「シンボリックリンクのパス」でアクセスできるようになる。
シンボリックリンクは「rm」で削除できます。

●ファイルを表示する
①cat
$ cat [ファイルパス] # 全件表示
$ cat -n [ファイルパス] # 行番号をつけた状態で全件表示


②ファイルの先頭N行を表示する
$ head -n [行数] [ファイルパス]

-n [行数]を省略すると、デフォルトで10行表示する。

③ファイルの最後のN行を表示する
$ tail -n [行数] [ファイルパス]

-n [行数]を省略すると、デフォルトで10行表示する。

⓸対象ファイルに行番号をつけた状態で最後の10行を表示する
$ cat -n work_file.txt | tail

catで行番号をつけたものをパイプでtailに引き渡す。

⑤M~N行目を表示する
$ head -n [最後の行数] [ファイルパス] | tail -n [後ろから数えた、表示したい行数]

もし行番号も表示したい場合は、下記のようにcatをパイプで繋いでやれば良い。
$ cat -n [ファイルパス] | head -n [最後の行数]| tail -n [後ろから数えた、表示したい行数]

⑥１ぺーじずつ表示する
でかいファイルを見るとき、1ページ分ずつ表示できると便利な時がある。
そういった際は「less」コマンドを使う。

$ less [ファイルパス]

spaceで次のページ。qで終了。bで前ページへ移動。
Enterで一行次へ進む。yで一行前へ戻る。
指定した行番号を一番上にして表示する場合は「行番号」を押してから「G」をクリック。

文字列検索したい場合は「/」を押したのちに検索したい文字列を入力してEnter。

⑦lessをもっと活用
行番号を表示、または文字列検索をあらかじめやる。


$ less -N -p[検索したい文字列] [ファイルパス]











●ファイルの改行コードを調べる
$ hexdump -c [ファイルパス]

行末に改行コードが表示されるので、それで確認。
「\n」はLF、「\r」はCR。


●ファイル中の文字列検索
grepを使おう。

①単純なgrepの説明
$ grep [検索したい文字列] [ファイルパス]
上記にて、検索したい文字列を含む行を表示する。
検索したい文字列にスペースとかが入っている際はクオテーションで囲ってあげることを忘れずに！

grepはデフォルトだと大文字、小文字を区別する。
区別させたくない際は「-i」オプションをつける。

grep -i [検索したい文字列] [ファイルパス] 


②ファイル中の文字列検索
cat -n [ファイルパス] | grep [検索したい文字列]

③指定した文字列を含まない行を表示
$ grep -v [検索したい文字列] [ファイルパス]

「v」オプションを使う。

④複数のファイルをまとめて検索
普通に複数ファイルを指定できる。
$ grep [検索したい文字列] [ファイルパス1] [ファイルパス2]
表示する際もどのファイルから検索したかを表示してくれるので便利！

⑤OR条件で「指定したいずれかの文字列を含む行」を表示する。
「-e」オプションを使う。
$ grep -e [検索したい文字列1] -e [検索したい文字列2] [ファイルパス] 

対象ファイルの上から順に表示する。


⑥AND条件で「指定した全ての文字列を含む行」を表示する
そんなオプションはないので、パイプで渡す。
$ grep [検索したい文字列1] [ファイルパス] | grep [検索したい文字列2]

⑦「○○から始まる行」のみを表示
正規表現(^)を使う。
$ grep '^[検索したい文字列]' [ファイルパス]

正規表現では^は行の先頭なので。


⑧「○○で終わる行」のみを表示
正規表現($)を使う。
$ grep '[検索したい文字列]$' [ファイルパス]

正規表現では$は行の終わりなので。


●viコマンドでテキストファイルを修正する
まだ実務で使ったことがない部分だけ整理。
いずれも、ビジュアルモードにすることが前提。
ビジュアルモードにするためには「ctrl + V」を押す。

①複数行をまとめて削除
複数行を選択して、「d」を押すだけ。

②コピー
複数行を選択して、「y」を押すだけ。

③ペースト
複数行を選択して、「p」を押すだけ。



●コマンドのマニュアルを表示
$ man [コマンド]
オンラインマニュアルが表示されるので、これで確認しよう。

コマンドの簡単な説明だけを表示するなら、「whtais」を使おう。
$ whatis [コマンド]


●ファイルを検索する
「fine」コマンドを使おう。
①findコマンドの基本的な使い方
$ find [起点となるディレクトリ] -name [名前]
起点となるディレクトリの下をどんどん掘り下げて検索してくれる。

②ファイル名で検索
例えば、カレントディレクトリ直下で「work」から始まるファイル、ディレクトリは下記で検索可能。
$ find . -name 'work*'

③更新日時で検索
$ find [起点となるディレクトリ] -mtime [日数]

実用例は下記の通り
$ find . -mtime 3 # ちょうど3日前に更新されたファイル
$ find . -mtime -3 # 3日前から現在までに更新されたファイル
$ find . -mtime +3 # 3日以上前に更新されたファイル

④アクセスした日時で検索
「③更新日時で検索」で「mtime」としていたところを「atime」にするだけ。


⑤検索対象をディレクトリ、ファイルのいずれにするかを指定する
「type」オプションを使う。

d,f,lの３種類の引数が指定できる。
$ find . -type f # カレントディレクトリ直下の全ファイルを検索
$ find . -type d # カレントディレクトリ直下の全ディレクトリを検索
$ find . -type l # カレントディレクトリ直下の全シンボリックリンクを検索

⑥ファイルのサイズで検索
「size」オプションを使う。

$ find . -size [サイズ]
特に指定しない場合は、サイズはブロック単位（512Byte)だが、後ろにkとかをつけるとKB単位で検索できたりする。
また、サイズの前に「+」をつけると「指定したサイズ以上」で検索するし、「-」をつけると「指定したサイズ以下」で検索する。

サイズの条件を２つ入れれば「範囲指定」のような検索もできる。
$ find . -size -900k -size +100k # 100KB~900KBのファイルを検索

⑦NOT条件
条件の前に「\!」をつける。

$ find . \! -name '*.txt' -name '*.???' # 拡張子がtxtでなく、かつ3文字のファイルを検索

⑧OR条件
findで色々条件を指定すると、それは「AND条件」で検索される。
「OR条件」で検索したい際は、「-o」オプションを使う。

$ find . -name "*.txt" -o -name "*.html" # カレントディレクトリ直下で、拡張子がtxtかhtmlのファイルを検索

⑨findで見つけたファイルに、更に別のコマンドを実行する
findの出力はパイプで別コマンドに繋げられないことが多い。
そんな時は別のコマンドを実行する「exec」オプションを使おう!

$ find [起点となるディレクトリ] -exec [実行するコマンド] {} \;
{}の部分にfindの出力結果が入る。

$ find . -name "*.txt" -exec ls -l {} \; # カレントディレクトリ直下で拡張子がtxtのファイルについて、lsで表示する
$ find . -name "*.txt" -print -exec cat -n {} \; # カレントディレクトリ直下で拡張子がtxtのファイルについて、行番号をつけて表示する

なお、「xargs」を使うほうがよりモダンかもしれない。

$ find . -name "*.txt" | xargs ls -l # カレントディレクトリ直下で拡張子がtxtのファイルについて、lsで表示する
$ find . -name "*.txt"| xargs cat -n # カレントディレクトリ直下で拡張子がtxtのファイルについて、行番号をつけて表示する

●ファイル圧縮と解凍
①gzip

$ gzip [対象ファイル] # 対象ファイルをgzip圧縮
元のファイルは削除され、新しく圧縮ファイルを作成する点に注意！
「v」オプションをつけると、圧縮率が表示されるのでちょっと便利。
$ gzip -v [対象ファイル] # 対象ファイルをgzip圧縮(圧縮率も表示)

$ gunzip [対象ファイル] # 対象gzipファイルを解凍
$ gzip -d [対象ファイル] # 対象gzipファイルを解凍
上記の２コマンドはどちらも同じ処理。好みで使う方を選んで。

②bzip2
コマンドの使い方は「gzip」と同じ。gzipの部分が「bzip2」になるだけ。



●アーカイブファイルの作成
「tar」コマンドを使う。

①tarファイル生成
$ tar -cvf [アーカイブファイルのパス] [アーカイブするディレクトリ]
c:新しいアーカイブを生成する
v:ファイルの情報を表示する
f:アーカイブファイルのパスを指定する

具体的には、下記のようなコマンドになる
$ tar -cvf work_tar.tar work* # カレントディレクトリ直下の「work」から始まる全ファイルを対象とした「work_tar.tar」ファイルを生成する

拡張子を自動でつけてくれないが、「tar」を使うことが一般的なので、[アーカイブするディレクトリ]で「.tar」を明示的に描いてあげよう！
当然、元のファイルはそのまま残る。（gzip,bzip2とは異なる）

②tarファイルの中身一覧を確認
$ tar -tvf [アーカイブファイルのパス]
tオプションが「一覧を表示する」というオプション

③アーカイブファイルを展開する
$ tar -xvf [アーカイブファイルのパス]
xオプションが「ファイルを展開する」というオプション。
展開した後も「tar」ファイルは残る。

Cオプションをつけることで、展開するディレクトリを指定できる。
（デフォルトだとカレントディレクトリ）
$ tar -xvf [アーカイブファイルのパス] -C [展開するディレクトリ]

具体的には、下記のようなコマンド
$ tar tar -xvf work_tar.tar -C ~/Desktop/ # work_tar.tarをDesktop直下に展開する


●圧縮アーカイブファイルの中身を確認する
単純にtarファイルを解凍してしまうと、新しくファイルができてしまう。
パイプで２つのコマンドをつないでやれば、そのようなことはなく単純に中身を確認できる。

$ gzip -dc [解凍するtarファイル] | tar -tvf - # tarファイルの中身一覧を確認

具体的なコマンドは下記の通り。
$ gzip -dc work_tar.tar.gz | tar -tvf - # work_tar.tar.gzファイルを解凍したものを標準出力に私、中身の一覧を表示
gzipのdオプションは解凍、cオプションは結果を標準出力に渡す。
tarの「-」は標準入力を標準出力から受け取る。

●圧縮アーカイブを展開する
アーカイブファイルの解凍、展開を一度にやるのも、パイプに渡せば一発ですよ。

$ gzip -dc [対象のtarファイル] | tar -xvf - # tarファイルの中身一覧を確認

●圧縮アーカイブファイルを一発で作成する
tarコマンドはよく使われるので、圧縮するオプションもついています。

$ tar -cvzf [アーカイブファイルのパス] [アーカイブするディレクトリ]
zオプションが「gzip」圧縮する、というもの。
zのところを「j」にするとbzip2形式の圧縮になる

上記ファイルの一覧表示はtvzfオプション。
$ tar -tvzf [アーカイブファイルのパス]

●ファイルの中身をソートする
「sort」コマンドを使おう。

①基本
$ sort [対象のファイル名] # デフォルトでは昇順
１列目を対象に並べ替える。
降順にしたい場合は「r」オプションをつける。

具体的には下記。
$ sort -r mail.csv # mail.csvを１列目を基準に降順に並べ替える

②列を指定してソート
$ sort -k [最初のフィールド番号],[最後のフィールド番号] [対象ファイル] # ファイルの拡張子がtsvか空白ならこれでokだが、csvの場合は拡張子を指定するオプションも必要 
$ sort -k 3,3 [対象ファイル] # 3番目のフィールドを基準にソート
$ sort -k 3,3 -t , [対象ファイル] # 3番目のフィールドを基準にソート。また、ファイルがcsvの場合は拡張子を指定する「t」オプションが必要

ただし、これは「文字列ベース」でのソートになる。
例えば「年齢」フィールドがあったとした場合は、数字ベースでソートすることがメインになるはず...。
数字ベースでソートするためには「n」オプションを使う。

$ sort -k 3,3 -n -t , [対象ファイル] # 3フィールド目を数字ベースで昇順ソート（csvファイル)

ソートした結果をファイル出力するなら、「>」で指定しよう。（行番号もつけてみました）
$ sort -r -k 3,3 -n -t , mail.csv | cat -n > work_mail.csv
これだと画面上に処理結果が表示されない。そのほうがいい時もあるかもしれないが、ファイル生成しつつ画面上にも表示したいこともあるよね。
そんな時は「tee」コマンドを使おう。
「tee」はファイル生成しつつ、標準出力（画面）にも結果を出力するもの。

$ sort -r -k 3,3 -n -t , mail.csv | cat -n | tee work_mail.csv # 画面に結果を表示しつつ、work_mail.csvファイルも生成


●重複行について
「uniq」コマンドを使おう。

①基本的な使い方
$ uniq [対象ファイル] # 全フィールドでの重複業を排除する
ただし、「uniq」コマンドは隣接レコード間でしか重複を検知できない。
そのため、あらかじめsortしたものをパイプで渡す必要があったり、何かと面倒...。
最近はsortに「u」オプションで重複削除ができるようになったので、それを使うほうがよろしい。

$ sort -u [対象ファイル] # ファイルをソートした後、重複を削除する

②重複行のみを表示する
dオプションをつけると、「重複行のみを表示」といったこともできる。
$ sort [対象ファイル] | uniq -d # 重複行のみを表示

③重複回数を表示する
cオプションを使う。
$ sort [対象ファイル] | uniq -c # 重複回数を表示

重複していない場合は、普通に1と出る。
下記のように、結果を渡してやれば重複回数の多い順にソートできる。
$ sort [対象ファイル] | uniq -c | sort -nrb # 重複回数の多い順に表示

sortの「b」オプションは「先頭のスペースを無視する」オプション。
ファイルの中身によっては不要。


●文字数をカウントする
「wc」コマンドを使おう。

①基本
$ wc [対象ファイル]

具体的にはこんな感じ
$ wc mail.txt # 行数、単語数、文字数（バイト数）の順に表示される 
2 4 66 mail.txt

複数ファイルを指定した場合は、ファイルごとの集計値と合計の集計値が表示される。
行数、単語数、文字数（バイト数）のうち表示する項目はオプションで指定できる。
l:行数
w:単語数
c:文字数（バイト数）

②ディレクトリ内のファイル数を表示
lsと組み合わせればできる。
$ ls | wc -l # 行数で見ること！

③検索された項目数をカウント
findコマンドと組み合わせる
$ find . -name '*.tsv' | wc -l # tsvファイルの個数をカウント


●文字列を置換、削除する
「tr」コマンドを使う。

①基本
「tr」コマンドでは直接ファイルを指定することができないので、純粋なフィルタコマンドと言える。
なので、下記のいずれかの方式でファイルをリダイレクトして指定する必要がある。

$ tr [文字1] [文字2] < [対象ファイルのパス]
$ cat [ファイルのパス] | tr [文字1] [文字2]

上記のコマンドでは、文字列1を文字列2に置換する。
また、「tr」コマンドは「1文字単位」での置換しかできない。とても使い勝手が悪い。

また、複数文字を一度に置換する場合は下記の通り。
$ tr abc ABC < [対象ファイルのパス] # aをA,bをB、cをCに置換する

②文字列を削除する
「tr」コマンドの「d」オプションを使う。

$ tr -d [削除したい文字]
実用イメージは下記の通り。
$ tr -d " " < [対象ファイルのパス] # スペースを削除
$ tr -d ab < [対象ファイルのパス] # a,bを削除


●ファイルの権限管理
①基本
Linuxでは、ファイルやディレクトリの権限を下記の３つの区分から管理している。
1.ユーザー
1-1.所有者
そのファイルの所有者
1-2.ユーザーの所属するグループ
ユーザーは複数のグループに属しているが、そのグループ
1-3.その他のユーザー
それ以外のユーザー

1-1から優先順位が高い。
なので、所属グループ的にファイルの書き込みが許可されていても、「所有者」として許可されていないようなら書き込みができない。

②権限の確認
「ls -l」コマンドで確認する。
一番左のフィールドで10文字ほど表示されるが、これの2~10文字目が権限について表示している部分。

drwxr-xr-x  4 yoshimurakeita  staff   128  7  1 01:23 Tips_linux
-rw-r--r--  1 yoshimurakeita  staff   454  7  1 00:26 mail.csv
drwxr-xr-x  2 yoshimurakeita  staff    64  6 30 23:24 tmp


2~4が所有者、5~7が所属グループ、8~10がその他のユーザーの権限を意味している。
r:読み込み
w:書き込み
x:実行

③権限変更
「chmod」コマンドで変更する。

$ chmod [利用者を表す記号] [オペレータ] [アクセス権] [ファイルのパス]

・利用者を表す記号
u:所有者
g:所属グループ
o:その他のユーザー
a:全て

・オペレータ
+:許可を加える
-:許可を取り消す
=:設定する（元の設定をクリアする）

・アクセス権
r:読み込み
w:書き込み
x:実行

具体的なコマンドのイメージは下記のとおり。
$ chmod a+w [ファイルのパス] # 全てのユーザーに書き込みを許可する
$ chmod o-rw [ファイルのパス] # その他のユーザーが読み込み、書き込みができないようにする

また、オペレータで「=」を使う際は少し注意が必要。
これは「今までの設定をクリアして、新しく権限を設定する」といったものになる。
$ chmod a=w [ファイルのパス] # 全てのユーザーに書き込みのみを許可する。（読み込み、実行ができなくなる）
$ chmod a=rwx [ファイルのパス] # 全てのユーザーが何でもできる

なお、ファイルの削除は上記の権限管理では制御できない。
ファイルの削除も制御したい場合は、ディレクトリのアクセス権を管理する必要がある。

また、下記の通り３桁の８進数で権限変更することもできる。
内容は同じで、ただ書き方の問題。
$ chmod 777 [対象ファイル] # 全ユーザーに全権限を付与！
$ chmod 700 [対象ファイル] # 所有者に全権限を付与し、グループ、その他のユーザーには全ての権限を剥奪
$ chmod 400 [対象ファイル] # 所有者に読み込み権限のみを付与し、グループ、その他のユーザーには全ての権限を剥奪
1桁目:所有者の権限
2桁目:所属グループの権限
3桁目:その他のユーザーの権限

r:権限ありなら4,なしなら0
w:権限ありなら2,なしなら0
x:権限ありなら1,なしなら0

④ディレクトリ以下をまとめて権限変更
「R」オプションをつける。
$ chmod -R 777 test # testディレクトリ以下について、全ユーザーに全権限を付与

●ディレクトリのアクセス権限
①基本
「ls -dl」コマンドで確認できる。
drwxr-xr-x  12 yoshimurakeita  staff  384  7  1 00:25 .

権限の読み方は「ファイルの権限管理」と同じ。
ただ、各権限のニュアンスが若干異なる。
r:ディレクトリ内のファイル一覧を表示できる
w:ディレクトリ内にファイルを作成、ファイル名変更、移動が可能
x:ディレクトリの下に進める


②権限変更
普通に「chmod」コマンドで変更可能


●ディスク使用量を確認する
「du」コマンドを使う。

①基本
$ du [ファイル or ディレクトリ] # デフォルトだとバイト単位でサイズを表示する
$ du [ディレクトリ/] # 対象ディレクトリ以下のディレクトリごとのディスク利用量を表示
$ du -a [ディレクトリ/] # ディレクトリのみならず、ファイルのディスク使用量も表示する
$ du -h [ファイル or ディレクトリ] # hオプションでファイルサイズの単位も表示する
$ du -s [ファイル or ディレクトリ] # ディスク使用量のみを表示する

②ディスク使用量の多い方から１０件のみを表示する
$ du -k ~ | sort -nr | head # hオプションを使うと、ファイルサイズに文字列が入ることになるので使ってはいけない。
$ du -ak /Users/yoshimurakeita/Desktop/work/20180630 | grep '\.txt$' | sort -nr | head # workディレクトリ直下の、拡張子が「txt」のファイルについて、サイズの大きい方から１０件のみを表示


●ファイルの情報について調べる
「file」コマンドを使おう。

①基本
$ file [対象ファイル] # 拡張子、文字コード等、対象ファイルの中身に応じて必要そうな情報を表示してくれる

●ファイルが改ざんされていないかを調べる
ファイルには「メッセージダイジェスト」と呼ばれる、指紋のような概念がある。
これはファイルを書き換えると変更されてしまうので、定期的に対象ファイルのメッセージダイジェストを記録して、ファイルが改竄されていないことを確認することでセキュリティを向上することができる。

①基本
$ md5sum [対象ファイル] # メッセージダイジェストを表示

よりビット数の多いメッセージダイジェストを生成する「sha1sum」、「sha512sum」コマンド等も存在する。


●OSの情報を表示
「uname」コマンドを使う。

①基本
$ uname # OS名を表示
$ uname -r # OSのバージョンを表示
$ uname -p # プロセッサの情報を表示
$ uname -a # 全ての情報を表示


●稼働状況を確認
「uptime」コマンドを使う。

①基本
$ uptime # 現在時刻、システムが起動してからの稼働時間、現在ログインしているユーザー数、直近1,5,15分間の平均負荷
平均負荷については「CPU１つあたりの待ちが発生している平均プロセス数」が表示される。


●メモリの使用状況を調べる
「free」コマンドを使う。

①基本
$ free # macOSだと使えなかった...。

●ログファイルの監視
「tail」コマンドを使う。

$ tail -f [ログファイル] # fオプションをつけることで、ファイルの最後を開いた状態で待ち状態になる
他にも使えるかもしれないが、ログファイルの監視くらいにしか用途が思いつかない。
終了するには「Ctrl + c」です。

●コマンド実行履歴を確認
「history」コマンドを使う。

①基本
$ history 
$ history 10 # 実行したコマンドを新しい方から10件表示
$ history | grep find | tail # find系のコマンドについて、新しい方から10件表示
$ ![ヒストリ番号] # historyで確認したヒストリ番号のコマンドを実行

●バックグラウンドジョブとして実行する
普通に実行すると「フォアグラウンドジョブ」と言われる形式で実行される。
これは、実行した処理が完了するまで、ターミナルエミュレータが捜査不能になる状態ですね。
それが嫌なら「バックグラウンドジョブ」として実行してやる必要がある。

①基本
$ [コマンド]& # コマンドの後に&をつけてやるだけ。スペースを入れても良い。


●エラー内容が不要な時
よく使われる方法として「/dev/null」にエラー内容を出力する、というやり方がある。
「/dev/null」特殊なファイルで、ここに出力されたデータは即時破棄される。

$ [コマンド] 2 > /dev/null

●コマンドの一時停止
「Ctrl + Z」で一時停止する。
一時停止したジョブを見るためには「jobs」を確認する。
一時停止した後に再実行したい場合は「fg」か「bg」を実行する。
（fgならフォアグラウンド、bgならバックグラウンドで実行する）

●コマンドの完全停止
「ctrl + c」

●ジョブを殺す
「jobs」でjob番号を調べて、「kill」で殺す。
ただし、「jobs」コマンドでは実行しているターミナルエミュレータでのジョブしか表示されない。
対象システムで実行されている全ジョブを対象にするなら「ps」コマンドを使う必要がある。
(psコマンドについて、「プロセスを確認」を参照)

$ jobs # 一時中止、実行されているジョブの一覧を表示
$ kill %[ジョブ番号] # 指定したジョブを殺す

「kill」コマンドは、デフォルトでは「SIGTERM」というシグナルを送ることでジョブを「停止」させている。
これでも停止されないジョブについては「SIGTERM」というシグナルを送ることで強制停止させる。

$ kill -s SIGKILL %[ジョブ番号] # 指定したジョブを強制停止する


●プロセスを確認
システム上で動いている全プロセス、ジョブ、タスクを確認する。
「ps」コマンドを使う。

①基本
$ ps
$ ps -e # システム内のすべてのプロセス一覧を表示
$ kill -s [シグナル] [プロセスID] # 対象プロセスIDにシグナルを送る
$ kill [プロセスID] # 対象プロセスIDを停止する

PID:プロセスID
TTY:動いているエミュレータ
TIME:実行時間
CMD:

  PID TTY           TIME CMD
  948 ttys000    0:01.57 -bash
 1434 ttys001    0:01.15 -bash
 2177 ttys001    0:00.00 tail


●for文
シェルでのfor文の書き方

①
$ for [変数名] in [変数のリスト] # 変数のリストはスペースで区切ること
$ do # 処理開始
$ [処理内容]
$ done # 処理終了

②拡張子がtxtのファイル一覧を表示
for a in *.txt
do
echo $a
done

③拡張子を変更（csvをtxtに）
for file in *.csv
do
mv $file ${file%.*}.txt # 拡張子を一度外して、その後にtxtをつける
done

上記では「パターン」という記法を使っている。
「${file%.*}.txt」の部分については、fileという変数の最後の部分から「.*」を削除して、その後にtxtをつけた状態でmvしているのである。
bashのパターン演算については「bashのパターン照合演算」を参照。

●bashのパターン照合演算

パターン 照合 演算子 説明 
＄ {変数%パターン}:変数の最後とパターンが一致した場合、一致する最短部分を削除して残りを戻す 
＄ {変数%%パターン}:変数の最後とパターンが一致した場合、一致する最長部分を削除して残りを戻す 
＄ {変数#パターン}:変数の最初とパターンが一致した場合、一致する最短部分を削除して残りを戻す 
＄ {変数##パターン}:変数の最初とパターンが一致した場合、一致する最長部分を削除して残りを戻す


●シェルファイルの実行
ファイルにシェルコマンドを書いておいて、実行するまでの流れ。

①基本
#! [シェルファイルの絶対パス]
[コマンド]

実行権限を確認すること。
また、「file」コマンドでシェルスクリプトとして認識されているかを確認する。

あとは、絶対パスでスクリプトを実行すればよろしい。


②シェルスクリプトの保存場所


UNIXの標準的なスクリプトの保存場所として、下記の４箇所があるが、ここに置くとOSのバージョンアップ時等に書き換えられるので、ここには置かないこと！
/bin
/sbin
/usr/bin
/usr/sbin

一般的には下記のいずれかに置くことになるかと。
/usr/local/bin:すべてのユーザーが利用するコマンド
~/bin:自分だけで使用するコマンド















