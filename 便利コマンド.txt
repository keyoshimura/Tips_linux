●セッション切れする時は...
screenコマンドを使おう。
http://kagasu.hatenablog.com/entry/20160627/1467012578
http://dasunhegoda.com/unix-screen-command/263/

名前をつけてscreenを作成
screen -S hoge

切り替え
screen -r　[processesID]

セッション一覧表示
screen -ls

名前をつけてscreenを作成（デタッチした状態で開始）
screen -dmS hoge

外部から終了する
screen -S hoge -X quit

外部から任意のコマンドを実行する
# 名前が hoge のセッションで ls を実行する
screen -S hoge -X stuff 'ls'`echo -ne '\015'`

screenを削除する。
コマンドでも削除できそうだけど、間違えて削除するのが怖いから、exitで抜けていけば削除できるのでそちらで。

まあ、どうしてもコマンドで消すのなら、下記のコマンドで「デタッチされている」スクリーンなら消せる。
screen -X -S SCREENID quit

・デタッチする
Ctrlと「A」を同時に押しましたのちに、D


●ディレクトリを削除
rm -rf ディレクトリ名

●結果をファイルに書き出す

・標準出力をファイルに書き出す（上書きしてしまうので注意）
>

・標準出力をファイルに書き出す（ファイルがあれば追加で書き出す）
>>

・標準エラー出力をファイルに書き出す（上書きしてしまうので注意）
2>

・標準エラー出力をファイルに書き出す（ファイルがあれば追加で書き出す）
2>>

・標準出力、エラー内容を同じファイルに書き出す（上書きしてしまうので注意）
>&

●ファイルコピー
①元ファイルの属性を保持したまま、ファイルコピーをする。（特に何も指定しないと、オーナーや更新日時が元ファイルと異なる）
「-p」オプションをつける。
$cp -p cat_test.txt cat_test_copied_2.txt


②ディレクトリを丸ごとコピーする
「R」オプションをつける。下記は「sample_1」ディレクトリをtmpディレクトリ直下にコピーしている。

$cp -R sample_1 tmp/ # tmpディレクトリ直下にコピー
上記コマンドを再度実行すると、同じ名前のファイルは上書きされる。
ただし、コピー元にないファイルについては、そのまま。

$cp -R sample_1 tmp/sample_2 # tmpディレクトリ直下に「sample_2」というディレクトリ名でコピー 
もし「tmp/sample_2」ディレクトリがすでに存在する場合は、「tmp/sample_2」ディレクトリ直下に「sample_1」ディレクトリが作成される。

③複数のファイルを、名前を指定してコピーする
$cp cat_test.txt cal.csv tmp # cat_test.txt、cal.csvをtmpディレクトリにコピーする

⓸カレントディレクトリを丸ごとコピー
$cp -pR . tmp # tmpディレクトリにコピー

「-p」オプションをつけて、ファイルの元属性をそのままコピーする。
「-R」オプションをつけることで、ディレクトリのコピーが可能。

●ファイル移動
mvコマンド。

①複数ファイルを移動
$ mv cal.csv cat_test.txt tmp # tmpディレクトリに移動


●シンボリックリンク作成
Windowsで言う所の「ショートカット」をLinuxでは「シンボリックリンク」もしくは「ハードリンク」と呼んでいる。
あまり使うことはないかと思いますが。

$ ln -s [元のファイルのパス] [シンボリックリンクのパス]
これで元ファイルに「シンボリックリンクのパス」でアクセスできるようになる。
シンボリックリンクは「rm」で削除できます。

●ファイルを表示する
①cat
$ cat [ファイルパス] # 全件表示
$ cat -n [ファイルパス] # 行番号をつけた状態で全件表示


②ファイルの先頭N行を表示する
$ head -n [行数] [ファイルパス]

-n [行数]を省略すると、デフォルトで10行表示する。

③ファイルの最後のN行を表示する
$ tail -n [行数] [ファイルパス]

-n [行数]を省略すると、デフォルトで10行表示する。

⓸対象ファイルに行番号をつけた状態で最後の10行を表示する
$ cat -n work_file.txt | tail

catで行番号をつけたものをパイプでtailに引き渡す。

⑤M~N行目を表示する
$ head -n [最後の行数] [ファイルパス] | tail -n [後ろから数えた、表示したい行数]

もし行番号も表示したい場合は、下記のようにcatをパイプで繋いでやれば良い。
$ cat -n [ファイルパス] | head -n [最後の行数]| tail -n [後ろから数えた、表示したい行数]

⑥１ぺーじずつ表示する
でかいファイルを見るとき、1ページ分ずつ表示できると便利な時がある。
そういった際は「less」コマンドを使う。

$ less [ファイルパス]

spaceで次のページ。qで終了。bで前ページへ移動。
Enterで一行次へ進む。yで一行前へ戻る。
指定した行番号を一番上にして表示する場合は「行番号」を押してから「G」をクリック。

文字列検索したい場合は「/」を押したのちに検索したい文字列を入力してEnter。

⑦lessをもっと活用
行番号を表示、または文字列検索をあらかじめやる。


$ less -N -p[検索したい文字列] [ファイルパス]











●ファイルの改行コードを調べる
$ hexdump -c [ファイルパス]

行末に改行コードが表示されるので、それで確認。
「\n」はLF、「\r」はCR。


●ファイル中の文字列検索
grepを使おう。

①単純なgrepの説明
$ grep [検索したい文字列] [ファイルパス]
上記にて、検索したい文字列を含む行を表示する。
検索したい文字列にスペースとかが入っている際はクオテーションで囲ってあげることを忘れずに！

grepはデフォルトだと大文字、小文字を区別する。
区別させたくない際は「-i」オプションをつける。

grep -i [検索したい文字列] [ファイルパス] 


②ファイル中の文字列検索
cat -n [ファイルパス] | grep [検索したい文字列]

③指定した文字列を含まない行を表示
$ grep -v [検索したい文字列] [ファイルパス]

「v」オプションを使う。

④複数のファイルをまとめて検索
普通に複数ファイルを指定できる。
$ grep [検索したい文字列] [ファイルパス1] [ファイルパス2]
表示する際もどのファイルから検索したかを表示してくれるので便利！

⑤OR条件で「指定したいずれかの文字列を含む行」を表示する。
「-e」オプションを使う。
$ grep -e [検索したい文字列1] -e [検索したい文字列2] [ファイルパス] 

対象ファイルの上から順に表示する。

⑥AND条件で「指定した全ての文字列を含む行」を表示する
そんなオプションはないので、パイプで渡す。
$ grep [検索したい文字列1] [ファイルパス] | grep [検索したい文字列2]

⑦「○○から始まる行」のみを表示
正規表現(^)を使う。
$ grep '^[検索したい文字列]' [ファイルパス]

正規表現では^は行の先頭なので。


⑧「○○で終わる行」のみを表示
正規表現($)を使う。
$ grep '[検索したい文字列]$' [ファイルパス]

正規表現では$は行の終わりなので。


●viコマンドでテキストファイルを修正する
まだ実務で使ったことがない部分だけ整理。
いずれも、ビジュアルモードにすることが前提。
ビジュアルモードにするためには「ctrl + V」を押す。

①複数行をまとめて削除
複数行を選択して、「d」を押すだけ。

②コピー
複数行を選択して、「y」を押すだけ。

③ペースト
複数行を選択して、「p」を押すだけ。



●コマンドのマニュアルを表示
$ man [コマンド]
オンラインマニュアルが表示されるので、これで確認しよう。

コマンドの簡単な説明だけを表示するなら、「whtais」を使おう。
$ whatis [コマンド]


●ファイルを検索する
「fine」コマンドを使おう。
①findコマンドの基本的な使い方
$ find [起点となるディレクトリ] -name [名前]
起点となるディレクトリの下をどんどん掘り下げて検索してくれる。

②ファイル名で検索
例えば、カレントディレクトリ直下で「work」から始まるファイル、ディレクトリは下記で検索可能。
$ find . -name 'work*'

③更新日時で検索
$ find [起点となるディレクトリ] -mtime [日数]

実用例は下記の通り
$ find . -mtime 3 # ちょうど3日前に更新されたファイル
$ find . -mtime -3 # 3日前から現在までに更新されたファイル
$ find . -mtime +3 # 3日以上前に更新されたファイル

④アクセスした日時で検索
「③更新日時で検索」で「mtime」としていたところを「atime」にするだけ。


⑤検索対象をディレクトリ、ファイルのいずれにするかを指定する
「type」オプションを使う。

d,f,lの３種類の引数が指定できる。
$ find . -type f # カレントディレクトリ直下の全ファイルを検索
$ find . -type d # カレントディレクトリ直下の全ディレクトリを検索
$ find . -type l # カレントディレクトリ直下の全シンボリックリンクを検索

⑥ファイルのサイズで検索
「size」オプションを使う。

$ find . -size [サイズ]
特に指定しない場合は、サイズはブロック単位（512Byte)だが、後ろにkとかをつけるとKB単位で検索できたりする。
また、サイズの前に「+」をつけると「指定したサイズ以上」で検索するし、「-」をつけると「指定したサイズ以下」で検索する。

サイズの条件を２つ入れれば「範囲指定」のような検索もできる。
$ find . -size -900k -size +100k # 100KB~900KBのファイルを検索

⑦NOT条件
条件の前に「\!」をつける。

$ find . \! -name '*.txt' -name '*.???' # 拡張子がtxtでなく、かつ3文字のファイルを検索

⑧OR条件
findで色々条件を指定すると、それは「AND条件」で検索される。
「OR条件」で検索したい際は、「-o」オプションを使う。

$ find . -name "*.txt" -o -name "*.html" # カレントディレクトリ直下で、拡張子がtxtかhtmlのファイルを検索

⑨findで見つけたファイルに、更に別のコマンドを実行する
findの出力はパイプで別コマンドに繋げられないことが多い。
そんな時は別のコマンドを実行する「exec」オプションを使おう!

$ find [起点となるディレクトリ] -exec [実行するコマンド] {} \;
{}の部分にfindの出力結果が入る。

$ find . -name "*.txt" -exec ls -l {} \; # カレントディレクトリ直下で拡張子がtxtのファイルについて、lsで表示する
$ find . -name "*.txt" -print -exec cat -n {} \; # カレントディレクトリ直下で拡張子がtxtのファイルについて、行番号をつけて表示する

なお、「xargs」を使うほうがよりモダンかもしれない。

$ find . -name "*.txt" | xargs ls -l # カレントディレクトリ直下で拡張子がtxtのファイルについて、lsで表示する
$ find . -name "*.txt"| xargs cat -n # カレントディレクトリ直下で拡張子がtxtのファイルについて、行番号をつけて表示する

●ファイル圧縮と解凍
①gzip

$ gzip [対象ファイル] # 対象ファイルをgzip圧縮
元のファイルは削除され、新しく圧縮ファイルを作成する点に注意！
「v」オプションをつけると、圧縮率が表示されるのでちょっと便利。
$ gzip -v [対象ファイル] # 対象ファイルをgzip圧縮(圧縮率も表示)

$ gunzip [対象ファイル] # 対象gzipファイルを解凍
$ gzip -d [対象ファイル] # 対象gzipファイルを解凍
上記の２コマンドはどちらも同じ処理。好みで使う方を選んで。

②bzip2
コマンドの使い方は「gzip」と同じ。gzipの部分が「bzip2」になるだけ。



●アーカイブファイルの作成
「tar」コマンドを使う。

①tarファイル生成
$ tar -cvf [アーカイブファイルのパス] [アーカイブするディレクトリ]
c:新しいアーカイブを生成する
v:ファイルの情報を表示する
f:アーカイブファイルのパスを指定する

具体的には、下記のようなコマンドになる
$ tar -cvf work_tar.tar work* # カレントディレクトリ直下の「work」から始まる全ファイルを対象とした「work_tar.tar」ファイルを生成する

拡張子を自動でつけてくれないが、「tar」を使うことが一般的なので、[アーカイブするディレクトリ]で「.tar」を明示的に描いてあげよう！
当然、元のファイルはそのまま残る。（gzip,bzip2とは異なる）

②tarファイルの中身一覧を確認
$ tar -tvf [アーカイブファイルのパス]
tオプションが「一覧を表示する」というオプション

③アーカイブファイルを展開する
$ tar -xvf [アーカイブファイルのパス]
xオプションが「ファイルを展開する」というオプション。
展開した後も「tar」ファイルは残る。

Cオプションをつけることで、展開するディレクトリを指定できる。
（デフォルトだとカレントディレクトリ）
$ tar -xvf [アーカイブファイルのパス] -C [展開するディレクトリ]

具体的には、下記のようなコマンド
$ tar tar -xvf work_tar.tar -C ~/Desktop/ # work_tar.tarをDesktop直下に展開する


●圧縮アーカイブファイルの中身を確認する
単純にtarファイルを解凍してしまうと、新しくファイルができてしまう。
パイプで２つのコマンドをつないでやれば、そのようなことはなく単純に中身を確認できる。

$ gzip -dc [解凍するtarファイル] | tar -tvf - # tarファイルの中身一覧を確認

具体的なコマンドは下記の通り。
$ gzip -dc work_tar.tar.gz | tar -tvf - # work_tar.tar.gzファイルを解凍したものを標準出力に私、中身の一覧を表示
gzipのdオプションは解凍、cオプションは結果を標準出力に渡す。
tarの「-」は標準入力を標準出力から受け取る。

●圧縮アーカイブを展開する
アーカイブファイルの解凍、展開を一度にやるのも、パイプに渡せば一発ですよ。

$ gzip -dc [対象のtarファイル] | tar -xvf - # tarファイルの中身一覧を確認

●圧縮アーカイブファイルを一発で作成する
tarコマンドはよく使われるので、圧縮するオプションもついています。

$ tar -cvzf [アーカイブファイルのパス] [アーカイブするディレクトリ]
zオプションが「gzip」圧縮する、というもの。
zのところを「j」にするとbzip2形式の圧縮になる

上記ファイルの一覧表示はtvzfオプション。
$ tar -tvzf [アーカイブファイルのパス]

●ファイルの中身をソートする
「sort」コマンドを使おう。

①基本
$ sort [対象のファイル名] # デフォルトでは昇順
１列目を対象に並べ替える。
降順にしたい場合は「r」オプションをつける。

具体的には下記。
$ sort -r mail.csv # mail.csvを１列目を基準に降順に並べ替える

②列を指定してソート
$ sort -k [最初のフィールド番号],[最後のフィールド番号] [対象ファイル] # ファイルの拡張子がtsvか空白ならこれでokだが、csvの場合は拡張子を指定するオプションも必要 
$ sort -k 3,3 [対象ファイル] # 3番目のフィールドを基準にソート
$ sort -k 3,3 -t , [対象ファイル] # 3番目のフィールドを基準にソート。また、ファイルがcsvの場合は拡張子を指定する「t」オプションが必要

ただし、これは「文字列ベース」でのソートになる。
例えば「年齢」フィールドがあったとした場合は、数字ベースでソートすることがメインになるはず...。
数字ベースでソートするためには「n」オプションを使う。

$ sort -k 3,3 -n -t , [対象ファイル] # 3フィールド目を数字ベースで昇順ソート（csvファイル)

ソートした結果をファイル出力するなら、「>」で指定しよう。（行番号もつけてみました）
$ sort -r -k 3,3 -n -t , mail.csv | cat -n > work_mail.csv
これだと画面上に処理結果が表示されない。そのほうがいい時もあるかもしれないが、ファイル生成しつつ画面上にも表示したいこともあるよね。
そんな時は「tee」コマンドを使おう。
「tee」はファイル生成しつつ、標準出力（画面）にも結果を出力するもの。

$ sort -r -k 3,3 -n -t , mail.csv | cat -n | tee work_mail.csv # 画面に結果を表示しつつ、work_mail.csvファイルも生成


●重複行について
「uniq」コマンドを使おう。

①基本的な使い方
$ uniq [対象ファイル] # 全フィールドでの重複業を排除する
ただし、「uniq」コマンドは隣接レコード間でしか重複を検知できない。
そのため、あらかじめsortしたものをパイプで渡す必要があったり、何かと面倒...。
最近はsortに「u」オプションで重複削除ができるようになったので、それを使うほうがよろしい。

$ sort -u [対象ファイル] # ファイルをソートした後、重複を削除する

②重複行のみを表示する
dオプションをつけると、「重複行のみを表示」といったこともできる。
$ sort [対象ファイル] | uniq -d # 重複行のみを表示

③重複回数を表示する
cオプションを使う。
$ sort [対象ファイル] | uniq -c # 重複回数を表示

重複していない場合は、普通に1と出る。
下記のように、結果を渡してやれば重複回数の多い順にソートできる。
$ sort [対象ファイル] | uniq -c | sort -nrb # 重複回数の多い順に表示

sortの「b」オプションは「先頭のスペースを無視する」オプション。
ファイルの中身によっては不要。


●文字数をカウントする
「wc」コマンドを使おう。

①基本
$ wc [対象ファイル]

具体的にはこんな感じ
$ wc mail.txt # 行数、単語数、文字数（バイト数）の順に表示される 
2 4 66 mail.txt

複数ファイルを指定した場合は、ファイルごとの集計値と合計の集計値が表示される。
行数、単語数、文字数（バイト数）のうち表示する項目はオプションで指定できる。
l:行数
w:単語数
c:文字数（バイト数）

②ディレクトリ内のファイル数を表示
lsと組み合わせればできる。
$ ls | wc -l # 行数で見ること！

③検索された項目数をカウント
findコマンドと組み合わせる
$ find . -name '*.tsv' | wc -l # tsvファイルの個数をカウント


●文字列を置換、削除する
「tr」コマンドを使う。

①基本
「tr」コマンドでは直接ファイルを指定することができないので、純粋なフィルタコマンドと言える。
なので、下記のいずれかの方式でファイルをリダイレクトして指定する必要がある。

$ tr [文字1] [文字2] < [対象ファイルのパス]
$ cat [ファイルのパス] | tr [文字1] [文字2]

上記のコマンドでは、文字列1を文字列2に置換する。
また、「tr」コマンドは「1文字単位」での置換しかできない。とても使い勝手が悪い。

また、複数文字を一度に置換する場合は下記の通り。
$ tr abc ABC < [対象ファイルのパス] # aをA,bをB、cをCに置換する

②文字列を削除する
「tr」コマンドの「d」オプションを使う。

$ tr -d [削除したい文字]
実用イメージは下記の通り。
$ tr -d " " < [対象ファイルのパス] # スペースを削除
$ tr -d ab < [対象ファイルのパス] # a,bを削除



















